/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

namespace Apache.Hadoop.Hbase.Thrift2
{
  public partial class THBaseService {
    public interface ISync {
      /// <summary>
      /// Test for the existence of columns in the table, as specified in the TGet.
      /// 
      /// @return true if the specified TGet matches one or more keys, false if not
      /// </summary>
      /// <param name="table">the table to check on</param>
      /// <param name="tget">the TGet to check for</param>
      bool exists(byte[] table, TGet tget);
      /// <summary>
      /// Test for the existence of columns in the table, as specified by the TGets.
      /// 
      /// This will return an array of booleans. Each value will be true if the related Get matches
      /// one or more keys, false if not.
      /// </summary>
      /// <param name="table">the table to check on</param>
      /// <param name="tgets">a list of TGets to check for</param>
      List<bool> existsAll(byte[] table, List<TGet> tgets);
      /// <summary>
      /// Method for getting data from a row.
      /// 
      /// If the row cannot be found an empty Result is returned.
      /// This can be checked by the empty field of the TResult
      /// 
      /// @return the result
      /// </summary>
      /// <param name="table">the table to get from</param>
      /// <param name="tget">the TGet to fetch</param>
      TResult @get(byte[] table, TGet tget);
      /// <summary>
      /// Method for getting multiple rows.
      /// 
      /// If a row cannot be found there will be a null
      /// value in the result list for that TGet at the
      /// same position.
      /// 
      /// So the Results are in the same order as the TGets.
      /// </summary>
      /// <param name="table">the table to get from</param>
      /// <param name="tgets">a list of TGets to fetch, the Result listwill have the Results at corresponding positionsor null if there was an error</param>
      List<TResult> getMultiple(byte[] table, List<TGet> tgets);
      /// <summary>
      /// Commit a TPut to a table.
      /// </summary>
      /// <param name="table">the table to put data in</param>
      /// <param name="tput">the TPut to put</param>
      void put(byte[] table, TPut tput);
      /// <summary>
      /// Atomically checks if a row/family/qualifier value matches the expected
      /// value. If it does, it adds the TPut.
      /// 
      /// @return true if the new put was executed, false otherwise
      /// </summary>
      /// <param name="table">to check in and put to</param>
      /// <param name="row">row to check</param>
      /// <param name="family">column family to check</param>
      /// <param name="qualifier">column qualifier to check</param>
      /// <param name="value">the expected value, if not provided thecheck is for the non-existence of thecolumn in question</param>
      /// <param name="tput">the TPut to put if the check succeeds</param>
      bool checkAndPut(byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TPut tput);
      /// <summary>
      /// Commit a List of Puts to the table.
      /// </summary>
      /// <param name="table">the table to put data in</param>
      /// <param name="tputs">a list of TPuts to commit</param>
      void putMultiple(byte[] table, List<TPut> tputs);
      /// <summary>
      /// Deletes as specified by the TDelete.
      /// 
      /// Note: "delete" is a reserved keyword and cannot be used in Thrift
      /// thus the inconsistent naming scheme from the other functions.
      /// </summary>
      /// <param name="table">the table to delete from</param>
      /// <param name="tdelete">the TDelete to delete</param>
      void deleteSingle(byte[] table, TDelete tdelete);
      /// <summary>
      /// Bulk commit a List of TDeletes to the table.
      /// 
      /// Throws a TIOError if any of the deletes fail.
      /// 
      /// Always returns an empty list for backwards compatibility.
      /// </summary>
      /// <param name="table">the table to delete from</param>
      /// <param name="tdeletes">list of TDeletes to delete</param>
      List<TDelete> deleteMultiple(byte[] table, List<TDelete> tdeletes);
      /// <summary>
      /// Atomically checks if a row/family/qualifier value matches the expected
      /// value. If it does, it adds the delete.
      /// 
      /// @return true if the new delete was executed, false otherwise
      /// </summary>
      /// <param name="table">to check in and delete from</param>
      /// <param name="row">row to check</param>
      /// <param name="family">column family to check</param>
      /// <param name="qualifier">column qualifier to check</param>
      /// <param name="value">the expected value, if not provided thecheck is for the non-existence of thecolumn in question</param>
      /// <param name="tdelete">the TDelete to execute if the check succeeds</param>
      bool checkAndDelete(byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TDelete tdelete);
      TResult increment(byte[] table, TIncrement tincrement);
      TResult append(byte[] table, TAppend tappend);
      /// <summary>
      /// Get a Scanner for the provided TScan object.
      /// 
      /// @return Scanner Id to be used with other scanner procedures
      /// </summary>
      /// <param name="table">the table to get the Scanner for</param>
      /// <param name="tscan">the scan object to get a Scanner for</param>
      int openScanner(byte[] table, TScan tscan);
      /// <summary>
      /// Grabs multiple rows from a Scanner.
      /// 
      /// @return Between zero and numRows TResults
      /// </summary>
      /// <param name="scannerId">the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.</param>
      /// <param name="numRows">number of rows to return</param>
      List<TResult> getScannerRows(int scannerId, int numRows);
      /// <summary>
      /// Closes the scanner. Should be called to free server side resources timely.
      /// Typically close once the scanner is not needed anymore, i.e. after looping
      /// over it to get all the required rows.
      /// </summary>
      /// <param name="scannerId">the Id of the Scanner to close *</param>
      void closeScanner(int scannerId);
      /// <summary>
      /// mutateRow performs multiple mutations atomically on a single row.
      /// </summary>
      /// <param name="table">table to apply the mutations</param>
      /// <param name="trowMutations">mutations to apply</param>
      void mutateRow(byte[] table, TRowMutations trowMutations);
      /// <summary>
      /// Get results for the provided TScan object.
      /// This helper function opens a scanner, get the results and close the scanner.
      /// 
      /// @return between zero and numRows TResults
      /// </summary>
      /// <param name="table">the table to get the Scanner for</param>
      /// <param name="tscan">the scan object to get a Scanner for</param>
      /// <param name="numRows">number of rows to return</param>
      List<TResult> getScannerResults(byte[] table, TScan tscan, int numRows);
      /// <summary>
      /// Given a table and a row get the location of the region that
      /// would contain the given row key.
      /// 
      /// reload = true means the cache will be cleared and the location
      /// will be fetched from meta.
      /// </summary>
      /// <param name="table"></param>
      /// <param name="row"></param>
      /// <param name="reload"></param>
      THRegionLocation getRegionLocation(byte[] table, byte[] row, bool reload);
      /// <summary>
      /// Get all of the region locations for a given table.
      /// 
      /// </summary>
      /// <param name="table"></param>
      List<THRegionLocation> getAllRegionLocations(byte[] table);
      /// <summary>
      /// Atomically checks if a row/family/qualifier value matches the expected
      /// value. If it does, it mutates the row.
      /// 
      /// @return true if the row was mutated, false otherwise
      /// </summary>
      /// <param name="table">to check in and delete from</param>
      /// <param name="row">row to check</param>
      /// <param name="family">column family to check</param>
      /// <param name="qualifier">column qualifier to check</param>
      /// <param name="compareOp">comparison to make on the value</param>
      /// <param name="value">the expected value to be compared against, if not provided thecheck is for the non-existence of the column in question</param>
      /// <param name="rowMutations">row mutations to execute if the value matches</param>
      bool checkAndMutate(byte[] table, byte[] row, byte[] family, byte[] qualifier, TCompareOp compareOp, byte[] @value, TRowMutations rowMutations);
    }

    public interface Iface : ISync {
      /// <summary>
      /// Test for the existence of columns in the table, as specified in the TGet.
      /// 
      /// @return true if the specified TGet matches one or more keys, false if not
      /// </summary>
      /// <param name="table">the table to check on</param>
      /// <param name="tget">the TGet to check for</param>
      #if SILVERLIGHT
      IAsyncResult Begin_exists(AsyncCallback callback, object state, byte[] table, TGet tget);
      bool End_exists(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Test for the existence of columns in the table, as specified by the TGets.
      /// 
      /// This will return an array of booleans. Each value will be true if the related Get matches
      /// one or more keys, false if not.
      /// </summary>
      /// <param name="table">the table to check on</param>
      /// <param name="tgets">a list of TGets to check for</param>
      #if SILVERLIGHT
      IAsyncResult Begin_existsAll(AsyncCallback callback, object state, byte[] table, List<TGet> tgets);
      List<bool> End_existsAll(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Method for getting data from a row.
      /// 
      /// If the row cannot be found an empty Result is returned.
      /// This can be checked by the empty field of the TResult
      /// 
      /// @return the result
      /// </summary>
      /// <param name="table">the table to get from</param>
      /// <param name="tget">the TGet to fetch</param>
      #if SILVERLIGHT
      IAsyncResult Begin_get(AsyncCallback callback, object state, byte[] table, TGet tget);
      TResult End_get(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Method for getting multiple rows.
      /// 
      /// If a row cannot be found there will be a null
      /// value in the result list for that TGet at the
      /// same position.
      /// 
      /// So the Results are in the same order as the TGets.
      /// </summary>
      /// <param name="table">the table to get from</param>
      /// <param name="tgets">a list of TGets to fetch, the Result listwill have the Results at corresponding positionsor null if there was an error</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getMultiple(AsyncCallback callback, object state, byte[] table, List<TGet> tgets);
      List<TResult> End_getMultiple(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Commit a TPut to a table.
      /// </summary>
      /// <param name="table">the table to put data in</param>
      /// <param name="tput">the TPut to put</param>
      #if SILVERLIGHT
      IAsyncResult Begin_put(AsyncCallback callback, object state, byte[] table, TPut tput);
      void End_put(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Atomically checks if a row/family/qualifier value matches the expected
      /// value. If it does, it adds the TPut.
      /// 
      /// @return true if the new put was executed, false otherwise
      /// </summary>
      /// <param name="table">to check in and put to</param>
      /// <param name="row">row to check</param>
      /// <param name="family">column family to check</param>
      /// <param name="qualifier">column qualifier to check</param>
      /// <param name="value">the expected value, if not provided thecheck is for the non-existence of thecolumn in question</param>
      /// <param name="tput">the TPut to put if the check succeeds</param>
      #if SILVERLIGHT
      IAsyncResult Begin_checkAndPut(AsyncCallback callback, object state, byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TPut tput);
      bool End_checkAndPut(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Commit a List of Puts to the table.
      /// </summary>
      /// <param name="table">the table to put data in</param>
      /// <param name="tputs">a list of TPuts to commit</param>
      #if SILVERLIGHT
      IAsyncResult Begin_putMultiple(AsyncCallback callback, object state, byte[] table, List<TPut> tputs);
      void End_putMultiple(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Deletes as specified by the TDelete.
      /// 
      /// Note: "delete" is a reserved keyword and cannot be used in Thrift
      /// thus the inconsistent naming scheme from the other functions.
      /// </summary>
      /// <param name="table">the table to delete from</param>
      /// <param name="tdelete">the TDelete to delete</param>
      #if SILVERLIGHT
      IAsyncResult Begin_deleteSingle(AsyncCallback callback, object state, byte[] table, TDelete tdelete);
      void End_deleteSingle(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Bulk commit a List of TDeletes to the table.
      /// 
      /// Throws a TIOError if any of the deletes fail.
      /// 
      /// Always returns an empty list for backwards compatibility.
      /// </summary>
      /// <param name="table">the table to delete from</param>
      /// <param name="tdeletes">list of TDeletes to delete</param>
      #if SILVERLIGHT
      IAsyncResult Begin_deleteMultiple(AsyncCallback callback, object state, byte[] table, List<TDelete> tdeletes);
      List<TDelete> End_deleteMultiple(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Atomically checks if a row/family/qualifier value matches the expected
      /// value. If it does, it adds the delete.
      /// 
      /// @return true if the new delete was executed, false otherwise
      /// </summary>
      /// <param name="table">to check in and delete from</param>
      /// <param name="row">row to check</param>
      /// <param name="family">column family to check</param>
      /// <param name="qualifier">column qualifier to check</param>
      /// <param name="value">the expected value, if not provided thecheck is for the non-existence of thecolumn in question</param>
      /// <param name="tdelete">the TDelete to execute if the check succeeds</param>
      #if SILVERLIGHT
      IAsyncResult Begin_checkAndDelete(AsyncCallback callback, object state, byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TDelete tdelete);
      bool End_checkAndDelete(IAsyncResult asyncResult);
      #endif
      #if SILVERLIGHT
      IAsyncResult Begin_increment(AsyncCallback callback, object state, byte[] table, TIncrement tincrement);
      TResult End_increment(IAsyncResult asyncResult);
      #endif
      #if SILVERLIGHT
      IAsyncResult Begin_append(AsyncCallback callback, object state, byte[] table, TAppend tappend);
      TResult End_append(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get a Scanner for the provided TScan object.
      /// 
      /// @return Scanner Id to be used with other scanner procedures
      /// </summary>
      /// <param name="table">the table to get the Scanner for</param>
      /// <param name="tscan">the scan object to get a Scanner for</param>
      #if SILVERLIGHT
      IAsyncResult Begin_openScanner(AsyncCallback callback, object state, byte[] table, TScan tscan);
      int End_openScanner(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Grabs multiple rows from a Scanner.
      /// 
      /// @return Between zero and numRows TResults
      /// </summary>
      /// <param name="scannerId">the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.</param>
      /// <param name="numRows">number of rows to return</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getScannerRows(AsyncCallback callback, object state, int scannerId, int numRows);
      List<TResult> End_getScannerRows(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Closes the scanner. Should be called to free server side resources timely.
      /// Typically close once the scanner is not needed anymore, i.e. after looping
      /// over it to get all the required rows.
      /// </summary>
      /// <param name="scannerId">the Id of the Scanner to close *</param>
      #if SILVERLIGHT
      IAsyncResult Begin_closeScanner(AsyncCallback callback, object state, int scannerId);
      void End_closeScanner(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// mutateRow performs multiple mutations atomically on a single row.
      /// </summary>
      /// <param name="table">table to apply the mutations</param>
      /// <param name="trowMutations">mutations to apply</param>
      #if SILVERLIGHT
      IAsyncResult Begin_mutateRow(AsyncCallback callback, object state, byte[] table, TRowMutations trowMutations);
      void End_mutateRow(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get results for the provided TScan object.
      /// This helper function opens a scanner, get the results and close the scanner.
      /// 
      /// @return between zero and numRows TResults
      /// </summary>
      /// <param name="table">the table to get the Scanner for</param>
      /// <param name="tscan">the scan object to get a Scanner for</param>
      /// <param name="numRows">number of rows to return</param>
      #if SILVERLIGHT
      IAsyncResult Begin_getScannerResults(AsyncCallback callback, object state, byte[] table, TScan tscan, int numRows);
      List<TResult> End_getScannerResults(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Given a table and a row get the location of the region that
      /// would contain the given row key.
      /// 
      /// reload = true means the cache will be cleared and the location
      /// will be fetched from meta.
      /// </summary>
      /// <param name="table"></param>
      /// <param name="row"></param>
      /// <param name="reload"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getRegionLocation(AsyncCallback callback, object state, byte[] table, byte[] row, bool reload);
      THRegionLocation End_getRegionLocation(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get all of the region locations for a given table.
      /// 
      /// </summary>
      /// <param name="table"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getAllRegionLocations(AsyncCallback callback, object state, byte[] table);
      List<THRegionLocation> End_getAllRegionLocations(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Atomically checks if a row/family/qualifier value matches the expected
      /// value. If it does, it mutates the row.
      /// 
      /// @return true if the row was mutated, false otherwise
      /// </summary>
      /// <param name="table">to check in and delete from</param>
      /// <param name="row">row to check</param>
      /// <param name="family">column family to check</param>
      /// <param name="qualifier">column qualifier to check</param>
      /// <param name="compareOp">comparison to make on the value</param>
      /// <param name="value">the expected value to be compared against, if not provided thecheck is for the non-existence of the column in question</param>
      /// <param name="rowMutations">row mutations to execute if the value matches</param>
      #if SILVERLIGHT
      IAsyncResult Begin_checkAndMutate(AsyncCallback callback, object state, byte[] table, byte[] row, byte[] family, byte[] qualifier, TCompareOp compareOp, byte[] @value, TRowMutations rowMutations);
      bool End_checkAndMutate(IAsyncResult asyncResult);
      #endif
    }

    public class Client : IDisposable, Iface {
      public Client(TProtocol prot) : this(prot, prot)
      {
      }

      public Client(TProtocol iprot, TProtocol oprot)
      {
        iprot_ = iprot;
        oprot_ = oprot;
      }

      protected TProtocol iprot_;
      protected TProtocol oprot_;
      protected int seqid_;

      public TProtocol InputProtocol
      {
        get { return iprot_; }
      }
      public TProtocol OutputProtocol
      {
        get { return oprot_; }
      }


      #region " IDisposable Support "
      private bool _IsDisposed;

      // IDisposable
      public void Dispose()
      {
        Dispose(true);
      }
      

      protected virtual void Dispose(bool disposing)
      {
        if (!_IsDisposed)
        {
          if (disposing)
          {
            if (iprot_ != null)
            {
              ((IDisposable)iprot_).Dispose();
            }
            if (oprot_ != null)
            {
              ((IDisposable)oprot_).Dispose();
            }
          }
        }
        _IsDisposed = true;
      }
      #endregion


      
      #if SILVERLIGHT
      public IAsyncResult Begin_exists(AsyncCallback callback, object state, byte[] table, TGet tget)
      {
        return send_exists(callback, state, table, tget);
      }

      public bool End_exists(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_exists();
      }

      #endif

      /// <summary>
      /// Test for the existence of columns in the table, as specified in the TGet.
      /// 
      /// @return true if the specified TGet matches one or more keys, false if not
      /// </summary>
      /// <param name="table">the table to check on</param>
      /// <param name="tget">the TGet to check for</param>
      public bool exists(byte[] table, TGet tget)
      {
        #if !SILVERLIGHT
        send_exists(table, tget);
        return recv_exists();

        #else
        var asyncResult = Begin_exists(null, null, table, tget);
        return End_exists(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_exists(AsyncCallback callback, object state, byte[] table, TGet tget)
      #else
      public void send_exists(byte[] table, TGet tget)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("exists", TMessageType.Call, seqid_));
        exists_args args = new exists_args();
        args.Table = table;
        args.Tget = tget;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public bool recv_exists()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        exists_result result = new exists_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "exists failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_existsAll(AsyncCallback callback, object state, byte[] table, List<TGet> tgets)
      {
        return send_existsAll(callback, state, table, tgets);
      }

      public List<bool> End_existsAll(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_existsAll();
      }

      #endif

      /// <summary>
      /// Test for the existence of columns in the table, as specified by the TGets.
      /// 
      /// This will return an array of booleans. Each value will be true if the related Get matches
      /// one or more keys, false if not.
      /// </summary>
      /// <param name="table">the table to check on</param>
      /// <param name="tgets">a list of TGets to check for</param>
      public List<bool> existsAll(byte[] table, List<TGet> tgets)
      {
        #if !SILVERLIGHT
        send_existsAll(table, tgets);
        return recv_existsAll();

        #else
        var asyncResult = Begin_existsAll(null, null, table, tgets);
        return End_existsAll(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_existsAll(AsyncCallback callback, object state, byte[] table, List<TGet> tgets)
      #else
      public void send_existsAll(byte[] table, List<TGet> tgets)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("existsAll", TMessageType.Call, seqid_));
        existsAll_args args = new existsAll_args();
        args.Table = table;
        args.Tgets = tgets;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<bool> recv_existsAll()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        existsAll_result result = new existsAll_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "existsAll failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_get(AsyncCallback callback, object state, byte[] table, TGet tget)
      {
        return send_get(callback, state, table, tget);
      }

      public TResult End_get(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_get();
      }

      #endif

      /// <summary>
      /// Method for getting data from a row.
      /// 
      /// If the row cannot be found an empty Result is returned.
      /// This can be checked by the empty field of the TResult
      /// 
      /// @return the result
      /// </summary>
      /// <param name="table">the table to get from</param>
      /// <param name="tget">the TGet to fetch</param>
      public TResult @get(byte[] table, TGet tget)
      {
        #if !SILVERLIGHT
        send_get(table, tget);
        return recv_get();

        #else
        var asyncResult = Begin_get(null, null, table, tget);
        return End_get(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_get(AsyncCallback callback, object state, byte[] table, TGet tget)
      #else
      public void send_get(byte[] table, TGet tget)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("get", TMessageType.Call, seqid_));
        get_args args = new get_args();
        args.Table = table;
        args.Tget = tget;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public TResult recv_get()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        get_result result = new get_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "get failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getMultiple(AsyncCallback callback, object state, byte[] table, List<TGet> tgets)
      {
        return send_getMultiple(callback, state, table, tgets);
      }

      public List<TResult> End_getMultiple(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getMultiple();
      }

      #endif

      /// <summary>
      /// Method for getting multiple rows.
      /// 
      /// If a row cannot be found there will be a null
      /// value in the result list for that TGet at the
      /// same position.
      /// 
      /// So the Results are in the same order as the TGets.
      /// </summary>
      /// <param name="table">the table to get from</param>
      /// <param name="tgets">a list of TGets to fetch, the Result listwill have the Results at corresponding positionsor null if there was an error</param>
      public List<TResult> getMultiple(byte[] table, List<TGet> tgets)
      {
        #if !SILVERLIGHT
        send_getMultiple(table, tgets);
        return recv_getMultiple();

        #else
        var asyncResult = Begin_getMultiple(null, null, table, tgets);
        return End_getMultiple(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getMultiple(AsyncCallback callback, object state, byte[] table, List<TGet> tgets)
      #else
      public void send_getMultiple(byte[] table, List<TGet> tgets)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getMultiple", TMessageType.Call, seqid_));
        getMultiple_args args = new getMultiple_args();
        args.Table = table;
        args.Tgets = tgets;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TResult> recv_getMultiple()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getMultiple_result result = new getMultiple_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getMultiple failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_put(AsyncCallback callback, object state, byte[] table, TPut tput)
      {
        return send_put(callback, state, table, tput);
      }

      public void End_put(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_put();
      }

      #endif

      /// <summary>
      /// Commit a TPut to a table.
      /// </summary>
      /// <param name="table">the table to put data in</param>
      /// <param name="tput">the TPut to put</param>
      public void put(byte[] table, TPut tput)
      {
        #if !SILVERLIGHT
        send_put(table, tput);
        recv_put();

        #else
        var asyncResult = Begin_put(null, null, table, tput);
        End_put(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_put(AsyncCallback callback, object state, byte[] table, TPut tput)
      #else
      public void send_put(byte[] table, TPut tput)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("put", TMessageType.Call, seqid_));
        put_args args = new put_args();
        args.Table = table;
        args.Tput = tput;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_put()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        put_result result = new put_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_checkAndPut(AsyncCallback callback, object state, byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TPut tput)
      {
        return send_checkAndPut(callback, state, table, row, family, qualifier, @value, tput);
      }

      public bool End_checkAndPut(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_checkAndPut();
      }

      #endif

      /// <summary>
      /// Atomically checks if a row/family/qualifier value matches the expected
      /// value. If it does, it adds the TPut.
      /// 
      /// @return true if the new put was executed, false otherwise
      /// </summary>
      /// <param name="table">to check in and put to</param>
      /// <param name="row">row to check</param>
      /// <param name="family">column family to check</param>
      /// <param name="qualifier">column qualifier to check</param>
      /// <param name="value">the expected value, if not provided thecheck is for the non-existence of thecolumn in question</param>
      /// <param name="tput">the TPut to put if the check succeeds</param>
      public bool checkAndPut(byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TPut tput)
      {
        #if !SILVERLIGHT
        send_checkAndPut(table, row, family, qualifier, @value, tput);
        return recv_checkAndPut();

        #else
        var asyncResult = Begin_checkAndPut(null, null, table, row, family, qualifier, @value, tput);
        return End_checkAndPut(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_checkAndPut(AsyncCallback callback, object state, byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TPut tput)
      #else
      public void send_checkAndPut(byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TPut tput)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("checkAndPut", TMessageType.Call, seqid_));
        checkAndPut_args args = new checkAndPut_args();
        args.Table = table;
        args.Row = row;
        args.Family = family;
        args.Qualifier = qualifier;
        args.Value = @value;
        args.Tput = tput;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public bool recv_checkAndPut()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        checkAndPut_result result = new checkAndPut_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "checkAndPut failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_putMultiple(AsyncCallback callback, object state, byte[] table, List<TPut> tputs)
      {
        return send_putMultiple(callback, state, table, tputs);
      }

      public void End_putMultiple(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_putMultiple();
      }

      #endif

      /// <summary>
      /// Commit a List of Puts to the table.
      /// </summary>
      /// <param name="table">the table to put data in</param>
      /// <param name="tputs">a list of TPuts to commit</param>
      public void putMultiple(byte[] table, List<TPut> tputs)
      {
        #if !SILVERLIGHT
        send_putMultiple(table, tputs);
        recv_putMultiple();

        #else
        var asyncResult = Begin_putMultiple(null, null, table, tputs);
        End_putMultiple(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_putMultiple(AsyncCallback callback, object state, byte[] table, List<TPut> tputs)
      #else
      public void send_putMultiple(byte[] table, List<TPut> tputs)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("putMultiple", TMessageType.Call, seqid_));
        putMultiple_args args = new putMultiple_args();
        args.Table = table;
        args.Tputs = tputs;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_putMultiple()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        putMultiple_result result = new putMultiple_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_deleteSingle(AsyncCallback callback, object state, byte[] table, TDelete tdelete)
      {
        return send_deleteSingle(callback, state, table, tdelete);
      }

      public void End_deleteSingle(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_deleteSingle();
      }

      #endif

      /// <summary>
      /// Deletes as specified by the TDelete.
      /// 
      /// Note: "delete" is a reserved keyword and cannot be used in Thrift
      /// thus the inconsistent naming scheme from the other functions.
      /// </summary>
      /// <param name="table">the table to delete from</param>
      /// <param name="tdelete">the TDelete to delete</param>
      public void deleteSingle(byte[] table, TDelete tdelete)
      {
        #if !SILVERLIGHT
        send_deleteSingle(table, tdelete);
        recv_deleteSingle();

        #else
        var asyncResult = Begin_deleteSingle(null, null, table, tdelete);
        End_deleteSingle(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_deleteSingle(AsyncCallback callback, object state, byte[] table, TDelete tdelete)
      #else
      public void send_deleteSingle(byte[] table, TDelete tdelete)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("deleteSingle", TMessageType.Call, seqid_));
        deleteSingle_args args = new deleteSingle_args();
        args.Table = table;
        args.Tdelete = tdelete;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_deleteSingle()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        deleteSingle_result result = new deleteSingle_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_deleteMultiple(AsyncCallback callback, object state, byte[] table, List<TDelete> tdeletes)
      {
        return send_deleteMultiple(callback, state, table, tdeletes);
      }

      public List<TDelete> End_deleteMultiple(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_deleteMultiple();
      }

      #endif

      /// <summary>
      /// Bulk commit a List of TDeletes to the table.
      /// 
      /// Throws a TIOError if any of the deletes fail.
      /// 
      /// Always returns an empty list for backwards compatibility.
      /// </summary>
      /// <param name="table">the table to delete from</param>
      /// <param name="tdeletes">list of TDeletes to delete</param>
      public List<TDelete> deleteMultiple(byte[] table, List<TDelete> tdeletes)
      {
        #if !SILVERLIGHT
        send_deleteMultiple(table, tdeletes);
        return recv_deleteMultiple();

        #else
        var asyncResult = Begin_deleteMultiple(null, null, table, tdeletes);
        return End_deleteMultiple(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_deleteMultiple(AsyncCallback callback, object state, byte[] table, List<TDelete> tdeletes)
      #else
      public void send_deleteMultiple(byte[] table, List<TDelete> tdeletes)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("deleteMultiple", TMessageType.Call, seqid_));
        deleteMultiple_args args = new deleteMultiple_args();
        args.Table = table;
        args.Tdeletes = tdeletes;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TDelete> recv_deleteMultiple()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        deleteMultiple_result result = new deleteMultiple_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "deleteMultiple failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_checkAndDelete(AsyncCallback callback, object state, byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TDelete tdelete)
      {
        return send_checkAndDelete(callback, state, table, row, family, qualifier, @value, tdelete);
      }

      public bool End_checkAndDelete(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_checkAndDelete();
      }

      #endif

      /// <summary>
      /// Atomically checks if a row/family/qualifier value matches the expected
      /// value. If it does, it adds the delete.
      /// 
      /// @return true if the new delete was executed, false otherwise
      /// </summary>
      /// <param name="table">to check in and delete from</param>
      /// <param name="row">row to check</param>
      /// <param name="family">column family to check</param>
      /// <param name="qualifier">column qualifier to check</param>
      /// <param name="value">the expected value, if not provided thecheck is for the non-existence of thecolumn in question</param>
      /// <param name="tdelete">the TDelete to execute if the check succeeds</param>
      public bool checkAndDelete(byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TDelete tdelete)
      {
        #if !SILVERLIGHT
        send_checkAndDelete(table, row, family, qualifier, @value, tdelete);
        return recv_checkAndDelete();

        #else
        var asyncResult = Begin_checkAndDelete(null, null, table, row, family, qualifier, @value, tdelete);
        return End_checkAndDelete(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_checkAndDelete(AsyncCallback callback, object state, byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TDelete tdelete)
      #else
      public void send_checkAndDelete(byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TDelete tdelete)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("checkAndDelete", TMessageType.Call, seqid_));
        checkAndDelete_args args = new checkAndDelete_args();
        args.Table = table;
        args.Row = row;
        args.Family = family;
        args.Qualifier = qualifier;
        args.Value = @value;
        args.Tdelete = tdelete;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public bool recv_checkAndDelete()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        checkAndDelete_result result = new checkAndDelete_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "checkAndDelete failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_increment(AsyncCallback callback, object state, byte[] table, TIncrement tincrement)
      {
        return send_increment(callback, state, table, tincrement);
      }

      public TResult End_increment(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_increment();
      }

      #endif

      public TResult increment(byte[] table, TIncrement tincrement)
      {
        #if !SILVERLIGHT
        send_increment(table, tincrement);
        return recv_increment();

        #else
        var asyncResult = Begin_increment(null, null, table, tincrement);
        return End_increment(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_increment(AsyncCallback callback, object state, byte[] table, TIncrement tincrement)
      #else
      public void send_increment(byte[] table, TIncrement tincrement)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("increment", TMessageType.Call, seqid_));
        increment_args args = new increment_args();
        args.Table = table;
        args.Tincrement = tincrement;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public TResult recv_increment()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        increment_result result = new increment_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "increment failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_append(AsyncCallback callback, object state, byte[] table, TAppend tappend)
      {
        return send_append(callback, state, table, tappend);
      }

      public TResult End_append(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_append();
      }

      #endif

      public TResult append(byte[] table, TAppend tappend)
      {
        #if !SILVERLIGHT
        send_append(table, tappend);
        return recv_append();

        #else
        var asyncResult = Begin_append(null, null, table, tappend);
        return End_append(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_append(AsyncCallback callback, object state, byte[] table, TAppend tappend)
      #else
      public void send_append(byte[] table, TAppend tappend)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("append", TMessageType.Call, seqid_));
        append_args args = new append_args();
        args.Table = table;
        args.Tappend = tappend;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public TResult recv_append()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        append_result result = new append_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "append failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_openScanner(AsyncCallback callback, object state, byte[] table, TScan tscan)
      {
        return send_openScanner(callback, state, table, tscan);
      }

      public int End_openScanner(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_openScanner();
      }

      #endif

      /// <summary>
      /// Get a Scanner for the provided TScan object.
      /// 
      /// @return Scanner Id to be used with other scanner procedures
      /// </summary>
      /// <param name="table">the table to get the Scanner for</param>
      /// <param name="tscan">the scan object to get a Scanner for</param>
      public int openScanner(byte[] table, TScan tscan)
      {
        #if !SILVERLIGHT
        send_openScanner(table, tscan);
        return recv_openScanner();

        #else
        var asyncResult = Begin_openScanner(null, null, table, tscan);
        return End_openScanner(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_openScanner(AsyncCallback callback, object state, byte[] table, TScan tscan)
      #else
      public void send_openScanner(byte[] table, TScan tscan)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("openScanner", TMessageType.Call, seqid_));
        openScanner_args args = new openScanner_args();
        args.Table = table;
        args.Tscan = tscan;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_openScanner()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        openScanner_result result = new openScanner_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "openScanner failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getScannerRows(AsyncCallback callback, object state, int scannerId, int numRows)
      {
        return send_getScannerRows(callback, state, scannerId, numRows);
      }

      public List<TResult> End_getScannerRows(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getScannerRows();
      }

      #endif

      /// <summary>
      /// Grabs multiple rows from a Scanner.
      /// 
      /// @return Between zero and numRows TResults
      /// </summary>
      /// <param name="scannerId">the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.</param>
      /// <param name="numRows">number of rows to return</param>
      public List<TResult> getScannerRows(int scannerId, int numRows)
      {
        #if !SILVERLIGHT
        send_getScannerRows(scannerId, numRows);
        return recv_getScannerRows();

        #else
        var asyncResult = Begin_getScannerRows(null, null, scannerId, numRows);
        return End_getScannerRows(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getScannerRows(AsyncCallback callback, object state, int scannerId, int numRows)
      #else
      public void send_getScannerRows(int scannerId, int numRows)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getScannerRows", TMessageType.Call, seqid_));
        getScannerRows_args args = new getScannerRows_args();
        args.ScannerId = scannerId;
        args.NumRows = numRows;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TResult> recv_getScannerRows()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getScannerRows_result result = new getScannerRows_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        if (result.__isset.ia) {
          throw result.Ia;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getScannerRows failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_closeScanner(AsyncCallback callback, object state, int scannerId)
      {
        return send_closeScanner(callback, state, scannerId);
      }

      public void End_closeScanner(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_closeScanner();
      }

      #endif

      /// <summary>
      /// Closes the scanner. Should be called to free server side resources timely.
      /// Typically close once the scanner is not needed anymore, i.e. after looping
      /// over it to get all the required rows.
      /// </summary>
      /// <param name="scannerId">the Id of the Scanner to close *</param>
      public void closeScanner(int scannerId)
      {
        #if !SILVERLIGHT
        send_closeScanner(scannerId);
        recv_closeScanner();

        #else
        var asyncResult = Begin_closeScanner(null, null, scannerId);
        End_closeScanner(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_closeScanner(AsyncCallback callback, object state, int scannerId)
      #else
      public void send_closeScanner(int scannerId)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("closeScanner", TMessageType.Call, seqid_));
        closeScanner_args args = new closeScanner_args();
        args.ScannerId = scannerId;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_closeScanner()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        closeScanner_result result = new closeScanner_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        if (result.__isset.ia) {
          throw result.Ia;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_mutateRow(AsyncCallback callback, object state, byte[] table, TRowMutations trowMutations)
      {
        return send_mutateRow(callback, state, table, trowMutations);
      }

      public void End_mutateRow(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_mutateRow();
      }

      #endif

      /// <summary>
      /// mutateRow performs multiple mutations atomically on a single row.
      /// </summary>
      /// <param name="table">table to apply the mutations</param>
      /// <param name="trowMutations">mutations to apply</param>
      public void mutateRow(byte[] table, TRowMutations trowMutations)
      {
        #if !SILVERLIGHT
        send_mutateRow(table, trowMutations);
        recv_mutateRow();

        #else
        var asyncResult = Begin_mutateRow(null, null, table, trowMutations);
        End_mutateRow(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_mutateRow(AsyncCallback callback, object state, byte[] table, TRowMutations trowMutations)
      #else
      public void send_mutateRow(byte[] table, TRowMutations trowMutations)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("mutateRow", TMessageType.Call, seqid_));
        mutateRow_args args = new mutateRow_args();
        args.Table = table;
        args.TrowMutations = trowMutations;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_mutateRow()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        mutateRow_result result = new mutateRow_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.io) {
          throw result.Io;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getScannerResults(AsyncCallback callback, object state, byte[] table, TScan tscan, int numRows)
      {
        return send_getScannerResults(callback, state, table, tscan, numRows);
      }

      public List<TResult> End_getScannerResults(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getScannerResults();
      }

      #endif

      /// <summary>
      /// Get results for the provided TScan object.
      /// This helper function opens a scanner, get the results and close the scanner.
      /// 
      /// @return between zero and numRows TResults
      /// </summary>
      /// <param name="table">the table to get the Scanner for</param>
      /// <param name="tscan">the scan object to get a Scanner for</param>
      /// <param name="numRows">number of rows to return</param>
      public List<TResult> getScannerResults(byte[] table, TScan tscan, int numRows)
      {
        #if !SILVERLIGHT
        send_getScannerResults(table, tscan, numRows);
        return recv_getScannerResults();

        #else
        var asyncResult = Begin_getScannerResults(null, null, table, tscan, numRows);
        return End_getScannerResults(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getScannerResults(AsyncCallback callback, object state, byte[] table, TScan tscan, int numRows)
      #else
      public void send_getScannerResults(byte[] table, TScan tscan, int numRows)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getScannerResults", TMessageType.Call, seqid_));
        getScannerResults_args args = new getScannerResults_args();
        args.Table = table;
        args.Tscan = tscan;
        args.NumRows = numRows;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<TResult> recv_getScannerResults()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getScannerResults_result result = new getScannerResults_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getScannerResults failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getRegionLocation(AsyncCallback callback, object state, byte[] table, byte[] row, bool reload)
      {
        return send_getRegionLocation(callback, state, table, row, reload);
      }

      public THRegionLocation End_getRegionLocation(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getRegionLocation();
      }

      #endif

      /// <summary>
      /// Given a table and a row get the location of the region that
      /// would contain the given row key.
      /// 
      /// reload = true means the cache will be cleared and the location
      /// will be fetched from meta.
      /// </summary>
      /// <param name="table"></param>
      /// <param name="row"></param>
      /// <param name="reload"></param>
      public THRegionLocation getRegionLocation(byte[] table, byte[] row, bool reload)
      {
        #if !SILVERLIGHT
        send_getRegionLocation(table, row, reload);
        return recv_getRegionLocation();

        #else
        var asyncResult = Begin_getRegionLocation(null, null, table, row, reload);
        return End_getRegionLocation(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getRegionLocation(AsyncCallback callback, object state, byte[] table, byte[] row, bool reload)
      #else
      public void send_getRegionLocation(byte[] table, byte[] row, bool reload)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getRegionLocation", TMessageType.Call, seqid_));
        getRegionLocation_args args = new getRegionLocation_args();
        args.Table = table;
        args.Row = row;
        args.Reload = reload;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public THRegionLocation recv_getRegionLocation()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getRegionLocation_result result = new getRegionLocation_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRegionLocation failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getAllRegionLocations(AsyncCallback callback, object state, byte[] table)
      {
        return send_getAllRegionLocations(callback, state, table);
      }

      public List<THRegionLocation> End_getAllRegionLocations(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getAllRegionLocations();
      }

      #endif

      /// <summary>
      /// Get all of the region locations for a given table.
      /// 
      /// </summary>
      /// <param name="table"></param>
      public List<THRegionLocation> getAllRegionLocations(byte[] table)
      {
        #if !SILVERLIGHT
        send_getAllRegionLocations(table);
        return recv_getAllRegionLocations();

        #else
        var asyncResult = Begin_getAllRegionLocations(null, null, table);
        return End_getAllRegionLocations(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getAllRegionLocations(AsyncCallback callback, object state, byte[] table)
      #else
      public void send_getAllRegionLocations(byte[] table)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getAllRegionLocations", TMessageType.Call, seqid_));
        getAllRegionLocations_args args = new getAllRegionLocations_args();
        args.Table = table;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<THRegionLocation> recv_getAllRegionLocations()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getAllRegionLocations_result result = new getAllRegionLocations_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getAllRegionLocations failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_checkAndMutate(AsyncCallback callback, object state, byte[] table, byte[] row, byte[] family, byte[] qualifier, TCompareOp compareOp, byte[] @value, TRowMutations rowMutations)
      {
        return send_checkAndMutate(callback, state, table, row, family, qualifier, compareOp, @value, rowMutations);
      }

      public bool End_checkAndMutate(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_checkAndMutate();
      }

      #endif

      /// <summary>
      /// Atomically checks if a row/family/qualifier value matches the expected
      /// value. If it does, it mutates the row.
      /// 
      /// @return true if the row was mutated, false otherwise
      /// </summary>
      /// <param name="table">to check in and delete from</param>
      /// <param name="row">row to check</param>
      /// <param name="family">column family to check</param>
      /// <param name="qualifier">column qualifier to check</param>
      /// <param name="compareOp">comparison to make on the value</param>
      /// <param name="value">the expected value to be compared against, if not provided thecheck is for the non-existence of the column in question</param>
      /// <param name="rowMutations">row mutations to execute if the value matches</param>
      public bool checkAndMutate(byte[] table, byte[] row, byte[] family, byte[] qualifier, TCompareOp compareOp, byte[] @value, TRowMutations rowMutations)
      {
        #if !SILVERLIGHT
        send_checkAndMutate(table, row, family, qualifier, compareOp, @value, rowMutations);
        return recv_checkAndMutate();

        #else
        var asyncResult = Begin_checkAndMutate(null, null, table, row, family, qualifier, compareOp, @value, rowMutations);
        return End_checkAndMutate(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_checkAndMutate(AsyncCallback callback, object state, byte[] table, byte[] row, byte[] family, byte[] qualifier, TCompareOp compareOp, byte[] @value, TRowMutations rowMutations)
      #else
      public void send_checkAndMutate(byte[] table, byte[] row, byte[] family, byte[] qualifier, TCompareOp compareOp, byte[] @value, TRowMutations rowMutations)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("checkAndMutate", TMessageType.Call, seqid_));
        checkAndMutate_args args = new checkAndMutate_args();
        args.Table = table;
        args.Row = row;
        args.Family = family;
        args.Qualifier = qualifier;
        args.CompareOp = compareOp;
        args.Value = @value;
        args.RowMutations = rowMutations;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public bool recv_checkAndMutate()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        checkAndMutate_result result = new checkAndMutate_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.io) {
          throw result.Io;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "checkAndMutate failed: unknown result");
      }

    }
    public class Processor : TProcessor {
      public Processor(ISync iface)
      {
        iface_ = iface;
        processMap_["exists"] = exists_Process;
        processMap_["existsAll"] = existsAll_Process;
        processMap_["get"] = get_Process;
        processMap_["getMultiple"] = getMultiple_Process;
        processMap_["put"] = put_Process;
        processMap_["checkAndPut"] = checkAndPut_Process;
        processMap_["putMultiple"] = putMultiple_Process;
        processMap_["deleteSingle"] = deleteSingle_Process;
        processMap_["deleteMultiple"] = deleteMultiple_Process;
        processMap_["checkAndDelete"] = checkAndDelete_Process;
        processMap_["increment"] = increment_Process;
        processMap_["append"] = append_Process;
        processMap_["openScanner"] = openScanner_Process;
        processMap_["getScannerRows"] = getScannerRows_Process;
        processMap_["closeScanner"] = closeScanner_Process;
        processMap_["mutateRow"] = mutateRow_Process;
        processMap_["getScannerResults"] = getScannerResults_Process;
        processMap_["getRegionLocation"] = getRegionLocation_Process;
        processMap_["getAllRegionLocations"] = getAllRegionLocations_Process;
        processMap_["checkAndMutate"] = checkAndMutate_Process;
      }

      protected delegate void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);
      private ISync iface_;
      protected Dictionary<string, ProcessFunction> processMap_ = new Dictionary<string, ProcessFunction>();

      public bool Process(TProtocol iprot, TProtocol oprot)
      {
        try
        {
          TMessage msg = iprot.ReadMessageBegin();
          ProcessFunction fn;
          processMap_.TryGetValue(msg.Name, out fn);
          if (fn == null) {
            TProtocolUtil.Skip(iprot, TType.Struct);
            iprot.ReadMessageEnd();
            TApplicationException x = new TApplicationException (TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '" + msg.Name + "'");
            oprot.WriteMessageBegin(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID));
            x.Write(oprot);
            oprot.WriteMessageEnd();
            oprot.Transport.Flush();
            return true;
          }
          fn(msg.SeqID, iprot, oprot);
        }
        catch (IOException)
        {
          return false;
        }
        return true;
      }

      public void exists_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        exists_args args = new exists_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        exists_result result = new exists_result();
        try
        {
          try
          {
            result.Success = iface_.exists(args.Table, args.Tget);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("exists", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("exists", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void existsAll_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        existsAll_args args = new existsAll_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        existsAll_result result = new existsAll_result();
        try
        {
          try
          {
            result.Success = iface_.existsAll(args.Table, args.Tgets);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("existsAll", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("existsAll", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void get_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        get_args args = new get_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        get_result result = new get_result();
        try
        {
          try
          {
            result.Success = iface_.@get(args.Table, args.Tget);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("get", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("get", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getMultiple_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getMultiple_args args = new getMultiple_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getMultiple_result result = new getMultiple_result();
        try
        {
          try
          {
            result.Success = iface_.getMultiple(args.Table, args.Tgets);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getMultiple", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getMultiple", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void put_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        put_args args = new put_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        put_result result = new put_result();
        try
        {
          try
          {
            iface_.put(args.Table, args.Tput);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("put", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("put", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void checkAndPut_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        checkAndPut_args args = new checkAndPut_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        checkAndPut_result result = new checkAndPut_result();
        try
        {
          try
          {
            result.Success = iface_.checkAndPut(args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Tput);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("checkAndPut", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("checkAndPut", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void putMultiple_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        putMultiple_args args = new putMultiple_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        putMultiple_result result = new putMultiple_result();
        try
        {
          try
          {
            iface_.putMultiple(args.Table, args.Tputs);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("putMultiple", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("putMultiple", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void deleteSingle_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        deleteSingle_args args = new deleteSingle_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        deleteSingle_result result = new deleteSingle_result();
        try
        {
          try
          {
            iface_.deleteSingle(args.Table, args.Tdelete);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("deleteSingle", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("deleteSingle", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void deleteMultiple_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        deleteMultiple_args args = new deleteMultiple_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        deleteMultiple_result result = new deleteMultiple_result();
        try
        {
          try
          {
            result.Success = iface_.deleteMultiple(args.Table, args.Tdeletes);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("deleteMultiple", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("deleteMultiple", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void checkAndDelete_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        checkAndDelete_args args = new checkAndDelete_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        checkAndDelete_result result = new checkAndDelete_result();
        try
        {
          try
          {
            result.Success = iface_.checkAndDelete(args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Tdelete);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("checkAndDelete", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("checkAndDelete", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void increment_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        increment_args args = new increment_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        increment_result result = new increment_result();
        try
        {
          try
          {
            result.Success = iface_.increment(args.Table, args.Tincrement);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("increment", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("increment", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void append_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        append_args args = new append_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        append_result result = new append_result();
        try
        {
          try
          {
            result.Success = iface_.append(args.Table, args.Tappend);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("append", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("append", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void openScanner_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        openScanner_args args = new openScanner_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        openScanner_result result = new openScanner_result();
        try
        {
          try
          {
            result.Success = iface_.openScanner(args.Table, args.Tscan);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("openScanner", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("openScanner", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getScannerRows_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getScannerRows_args args = new getScannerRows_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getScannerRows_result result = new getScannerRows_result();
        try
        {
          try
          {
            result.Success = iface_.getScannerRows(args.ScannerId, args.NumRows);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          catch (TIllegalArgument ia)
          {
            result.Ia = ia;
          }
          oprot.WriteMessageBegin(new TMessage("getScannerRows", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getScannerRows", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void closeScanner_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        closeScanner_args args = new closeScanner_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        closeScanner_result result = new closeScanner_result();
        try
        {
          try
          {
            iface_.closeScanner(args.ScannerId);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          catch (TIllegalArgument ia)
          {
            result.Ia = ia;
          }
          oprot.WriteMessageBegin(new TMessage("closeScanner", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("closeScanner", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void mutateRow_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        mutateRow_args args = new mutateRow_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        mutateRow_result result = new mutateRow_result();
        try
        {
          try
          {
            iface_.mutateRow(args.Table, args.TrowMutations);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("mutateRow", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("mutateRow", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getScannerResults_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getScannerResults_args args = new getScannerResults_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getScannerResults_result result = new getScannerResults_result();
        try
        {
          try
          {
            result.Success = iface_.getScannerResults(args.Table, args.Tscan, args.NumRows);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getScannerResults", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getScannerResults", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getRegionLocation_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getRegionLocation_args args = new getRegionLocation_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getRegionLocation_result result = new getRegionLocation_result();
        try
        {
          try
          {
            result.Success = iface_.getRegionLocation(args.Table, args.Row, args.Reload);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getRegionLocation", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getRegionLocation", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getAllRegionLocations_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getAllRegionLocations_args args = new getAllRegionLocations_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getAllRegionLocations_result result = new getAllRegionLocations_result();
        try
        {
          try
          {
            result.Success = iface_.getAllRegionLocations(args.Table);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("getAllRegionLocations", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getAllRegionLocations", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void checkAndMutate_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        checkAndMutate_args args = new checkAndMutate_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        checkAndMutate_result result = new checkAndMutate_result();
        try
        {
          try
          {
            result.Success = iface_.checkAndMutate(args.Table, args.Row, args.Family, args.Qualifier, args.CompareOp, args.Value, args.RowMutations);
          }
          catch (TIOError io)
          {
            result.Io = io;
          }
          oprot.WriteMessageBegin(new TMessage("checkAndMutate", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("checkAndMutate", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class exists_args : TBase
    {

      /// <summary>
      /// the table to check on
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// the TGet to check for
      /// </summary>
      public TGet Tget { get; set; }

      public exists_args() {
      }

      public exists_args(byte[] table, TGet tget) : this() {
        this.Table = table;
        this.Tget = tget;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_tget = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Tget = new TGet();
                  Tget.Read(iprot);
                  isset_tget = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_tget)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tget not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("exists_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Tget == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tget not set");
          field.Name = "tget";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Tget.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("exists_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Tget: ");
        __sb.Append(Tget== null ? "<null>" : Tget.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class exists_result : TBase
    {
      private bool _success;
      private TIOError _io;

      public bool Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public exists_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Bool) {
                  Success = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("exists_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.Bool;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("exists_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class existsAll_args : TBase
    {

      /// <summary>
      /// the table to check on
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// a list of TGets to check for
      /// </summary>
      public List<TGet> Tgets { get; set; }

      public existsAll_args() {
      }

      public existsAll_args(byte[] table, List<TGet> tgets) : this() {
        this.Table = table;
        this.Tgets = tgets;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_tgets = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.List) {
                  {
                    Tgets = new List<TGet>();
                    TList _list71 = iprot.ReadListBegin();
                    for( int _i72 = 0; _i72 < _list71.Count; ++_i72)
                    {
                      TGet _elem73;
                      _elem73 = new TGet();
                      _elem73.Read(iprot);
                      Tgets.Add(_elem73);
                    }
                    iprot.ReadListEnd();
                  }
                  isset_tgets = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_tgets)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tgets not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("existsAll_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Tgets == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tgets not set");
          field.Name = "tgets";
          field.Type = TType.List;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.Struct, Tgets.Count));
            foreach (TGet _iter74 in Tgets)
            {
              _iter74.Write(oprot);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("existsAll_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Tgets: ");
        __sb.Append(Tgets);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class existsAll_result : TBase
    {
      private List<bool> _success;
      private TIOError _io;

      public List<bool> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public existsAll_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<bool>();
                    TList _list75 = iprot.ReadListBegin();
                    for( int _i76 = 0; _i76 < _list75.Count; ++_i76)
                    {
                      bool _elem77;
                      _elem77 = iprot.ReadBool();
                      Success.Add(_elem77);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("existsAll_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Bool, Success.Count));
                foreach (bool _iter78 in Success)
                {
                  oprot.WriteBool(_iter78);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("existsAll_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_args : TBase
    {

      /// <summary>
      /// the table to get from
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// the TGet to fetch
      /// </summary>
      public TGet Tget { get; set; }

      public get_args() {
      }

      public get_args(byte[] table, TGet tget) : this() {
        this.Table = table;
        this.Tget = tget;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_tget = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Tget = new TGet();
                  Tget.Read(iprot);
                  isset_tget = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_tget)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tget not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Tget == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tget not set");
          field.Name = "tget";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Tget.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Tget: ");
        __sb.Append(Tget== null ? "<null>" : Tget.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class get_result : TBase
    {
      private TResult _success;
      private TIOError _io;

      public TResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public get_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new TResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("get_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("get_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getMultiple_args : TBase
    {

      /// <summary>
      /// the table to get from
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// a list of TGets to fetch, the Result list
      /// will have the Results at corresponding positions
      /// or null if there was an error
      /// </summary>
      public List<TGet> Tgets { get; set; }

      public getMultiple_args() {
      }

      public getMultiple_args(byte[] table, List<TGet> tgets) : this() {
        this.Table = table;
        this.Tgets = tgets;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_tgets = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.List) {
                  {
                    Tgets = new List<TGet>();
                    TList _list79 = iprot.ReadListBegin();
                    for( int _i80 = 0; _i80 < _list79.Count; ++_i80)
                    {
                      TGet _elem81;
                      _elem81 = new TGet();
                      _elem81.Read(iprot);
                      Tgets.Add(_elem81);
                    }
                    iprot.ReadListEnd();
                  }
                  isset_tgets = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_tgets)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tgets not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getMultiple_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Tgets == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tgets not set");
          field.Name = "tgets";
          field.Type = TType.List;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.Struct, Tgets.Count));
            foreach (TGet _iter82 in Tgets)
            {
              _iter82.Write(oprot);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getMultiple_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Tgets: ");
        __sb.Append(Tgets);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getMultiple_result : TBase
    {
      private List<TResult> _success;
      private TIOError _io;

      public List<TResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getMultiple_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TResult>();
                    TList _list83 = iprot.ReadListBegin();
                    for( int _i84 = 0; _i84 < _list83.Count; ++_i84)
                    {
                      TResult _elem85;
                      _elem85 = new TResult();
                      _elem85.Read(iprot);
                      Success.Add(_elem85);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getMultiple_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TResult _iter86 in Success)
                {
                  _iter86.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getMultiple_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class put_args : TBase
    {

      /// <summary>
      /// the table to put data in
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// the TPut to put
      /// </summary>
      public TPut Tput { get; set; }

      public put_args() {
      }

      public put_args(byte[] table, TPut tput) : this() {
        this.Table = table;
        this.Tput = tput;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_tput = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Tput = new TPut();
                  Tput.Read(iprot);
                  isset_tput = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_tput)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tput not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("put_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Tput == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tput not set");
          field.Name = "tput";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Tput.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("put_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Tput: ");
        __sb.Append(Tput== null ? "<null>" : Tput.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class put_result : TBase
    {
      private TIOError _io;

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public put_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("put_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("put_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class checkAndPut_args : TBase
    {
      private byte[] _value;

      /// <summary>
      /// to check in and put to
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// row to check
      /// </summary>
      public byte[] Row { get; set; }

      /// <summary>
      /// column family to check
      /// </summary>
      public byte[] Family { get; set; }

      /// <summary>
      /// column qualifier to check
      /// </summary>
      public byte[] Qualifier { get; set; }

      /// <summary>
      /// the expected value, if not provided the
      /// check is for the non-existence of the
      /// column in question
      /// </summary>
      public byte[] Value
      {
        get
        {
          return _value;
        }
        set
        {
          __isset.@value = true;
          this._value = value;
        }
      }

      /// <summary>
      /// the TPut to put if the check succeeds
      /// </summary>
      public TPut Tput { get; set; }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool @value;
      }

      public checkAndPut_args() {
      }

      public checkAndPut_args(byte[] table, byte[] row, byte[] family, byte[] qualifier, TPut tput) : this() {
        this.Table = table;
        this.Row = row;
        this.Family = family;
        this.Qualifier = qualifier;
        this.Tput = tput;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_row = false;
          bool isset_family = false;
          bool isset_qualifier = false;
          bool isset_tput = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                  isset_row = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Family = iprot.ReadBinary();
                  isset_family = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.String) {
                  Qualifier = iprot.ReadBinary();
                  isset_qualifier = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.String) {
                  Value = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 6:
                if (field.Type == TType.Struct) {
                  Tput = new TPut();
                  Tput.Read(iprot);
                  isset_tput = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_row)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Row not set");
          if (!isset_family)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Family not set");
          if (!isset_qualifier)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Qualifier not set");
          if (!isset_tput)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tput not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("checkAndPut_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Row == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Row not set");
          field.Name = "row";
          field.Type = TType.String;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Row);
          oprot.WriteFieldEnd();
          if (Family == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Family not set");
          field.Name = "family";
          field.Type = TType.String;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Family);
          oprot.WriteFieldEnd();
          if (Qualifier == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Qualifier not set");
          field.Name = "qualifier";
          field.Type = TType.String;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Qualifier);
          oprot.WriteFieldEnd();
          if (Value != null && __isset.@value) {
            field.Name = "value";
            field.Type = TType.String;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Value);
            oprot.WriteFieldEnd();
          }
          if (Tput == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tput not set");
          field.Name = "tput";
          field.Type = TType.Struct;
          field.ID = 6;
          oprot.WriteFieldBegin(field);
          Tput.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("checkAndPut_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Row: ");
        __sb.Append(Row);
        __sb.Append(", Family: ");
        __sb.Append(Family);
        __sb.Append(", Qualifier: ");
        __sb.Append(Qualifier);
        if (Value != null && __isset.@value) {
          __sb.Append(", Value: ");
          __sb.Append(Value);
        }
        __sb.Append(", Tput: ");
        __sb.Append(Tput== null ? "<null>" : Tput.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class checkAndPut_result : TBase
    {
      private bool _success;
      private TIOError _io;

      public bool Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public checkAndPut_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Bool) {
                  Success = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("checkAndPut_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.Bool;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("checkAndPut_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class putMultiple_args : TBase
    {

      /// <summary>
      /// the table to put data in
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// a list of TPuts to commit
      /// </summary>
      public List<TPut> Tputs { get; set; }

      public putMultiple_args() {
      }

      public putMultiple_args(byte[] table, List<TPut> tputs) : this() {
        this.Table = table;
        this.Tputs = tputs;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_tputs = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.List) {
                  {
                    Tputs = new List<TPut>();
                    TList _list87 = iprot.ReadListBegin();
                    for( int _i88 = 0; _i88 < _list87.Count; ++_i88)
                    {
                      TPut _elem89;
                      _elem89 = new TPut();
                      _elem89.Read(iprot);
                      Tputs.Add(_elem89);
                    }
                    iprot.ReadListEnd();
                  }
                  isset_tputs = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_tputs)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tputs not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("putMultiple_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Tputs == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tputs not set");
          field.Name = "tputs";
          field.Type = TType.List;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.Struct, Tputs.Count));
            foreach (TPut _iter90 in Tputs)
            {
              _iter90.Write(oprot);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("putMultiple_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Tputs: ");
        __sb.Append(Tputs);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class putMultiple_result : TBase
    {
      private TIOError _io;

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public putMultiple_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("putMultiple_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("putMultiple_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteSingle_args : TBase
    {

      /// <summary>
      /// the table to delete from
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// the TDelete to delete
      /// </summary>
      public TDelete Tdelete { get; set; }

      public deleteSingle_args() {
      }

      public deleteSingle_args(byte[] table, TDelete tdelete) : this() {
        this.Table = table;
        this.Tdelete = tdelete;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_tdelete = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Tdelete = new TDelete();
                  Tdelete.Read(iprot);
                  isset_tdelete = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_tdelete)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tdelete not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteSingle_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Tdelete == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tdelete not set");
          field.Name = "tdelete";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Tdelete.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteSingle_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Tdelete: ");
        __sb.Append(Tdelete== null ? "<null>" : Tdelete.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteSingle_result : TBase
    {
      private TIOError _io;

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public deleteSingle_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteSingle_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteSingle_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteMultiple_args : TBase
    {

      /// <summary>
      /// the table to delete from
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// list of TDeletes to delete
      /// </summary>
      public List<TDelete> Tdeletes { get; set; }

      public deleteMultiple_args() {
      }

      public deleteMultiple_args(byte[] table, List<TDelete> tdeletes) : this() {
        this.Table = table;
        this.Tdeletes = tdeletes;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_tdeletes = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.List) {
                  {
                    Tdeletes = new List<TDelete>();
                    TList _list91 = iprot.ReadListBegin();
                    for( int _i92 = 0; _i92 < _list91.Count; ++_i92)
                    {
                      TDelete _elem93;
                      _elem93 = new TDelete();
                      _elem93.Read(iprot);
                      Tdeletes.Add(_elem93);
                    }
                    iprot.ReadListEnd();
                  }
                  isset_tdeletes = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_tdeletes)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tdeletes not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteMultiple_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Tdeletes == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tdeletes not set");
          field.Name = "tdeletes";
          field.Type = TType.List;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.Struct, Tdeletes.Count));
            foreach (TDelete _iter94 in Tdeletes)
            {
              _iter94.Write(oprot);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteMultiple_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Tdeletes: ");
        __sb.Append(Tdeletes);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteMultiple_result : TBase
    {
      private List<TDelete> _success;
      private TIOError _io;

      public List<TDelete> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public deleteMultiple_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TDelete>();
                    TList _list95 = iprot.ReadListBegin();
                    for( int _i96 = 0; _i96 < _list95.Count; ++_i96)
                    {
                      TDelete _elem97;
                      _elem97 = new TDelete();
                      _elem97.Read(iprot);
                      Success.Add(_elem97);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteMultiple_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TDelete _iter98 in Success)
                {
                  _iter98.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteMultiple_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class checkAndDelete_args : TBase
    {
      private byte[] _value;

      /// <summary>
      /// to check in and delete from
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// row to check
      /// </summary>
      public byte[] Row { get; set; }

      /// <summary>
      /// column family to check
      /// </summary>
      public byte[] Family { get; set; }

      /// <summary>
      /// column qualifier to check
      /// </summary>
      public byte[] Qualifier { get; set; }

      /// <summary>
      /// the expected value, if not provided the
      /// check is for the non-existence of the
      /// column in question
      /// </summary>
      public byte[] Value
      {
        get
        {
          return _value;
        }
        set
        {
          __isset.@value = true;
          this._value = value;
        }
      }

      /// <summary>
      /// the TDelete to execute if the check succeeds
      /// </summary>
      public TDelete Tdelete { get; set; }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool @value;
      }

      public checkAndDelete_args() {
      }

      public checkAndDelete_args(byte[] table, byte[] row, byte[] family, byte[] qualifier, TDelete tdelete) : this() {
        this.Table = table;
        this.Row = row;
        this.Family = family;
        this.Qualifier = qualifier;
        this.Tdelete = tdelete;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_row = false;
          bool isset_family = false;
          bool isset_qualifier = false;
          bool isset_tdelete = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                  isset_row = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Family = iprot.ReadBinary();
                  isset_family = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.String) {
                  Qualifier = iprot.ReadBinary();
                  isset_qualifier = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.String) {
                  Value = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 6:
                if (field.Type == TType.Struct) {
                  Tdelete = new TDelete();
                  Tdelete.Read(iprot);
                  isset_tdelete = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_row)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Row not set");
          if (!isset_family)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Family not set");
          if (!isset_qualifier)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Qualifier not set");
          if (!isset_tdelete)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tdelete not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("checkAndDelete_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Row == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Row not set");
          field.Name = "row";
          field.Type = TType.String;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Row);
          oprot.WriteFieldEnd();
          if (Family == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Family not set");
          field.Name = "family";
          field.Type = TType.String;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Family);
          oprot.WriteFieldEnd();
          if (Qualifier == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Qualifier not set");
          field.Name = "qualifier";
          field.Type = TType.String;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Qualifier);
          oprot.WriteFieldEnd();
          if (Value != null && __isset.@value) {
            field.Name = "value";
            field.Type = TType.String;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Value);
            oprot.WriteFieldEnd();
          }
          if (Tdelete == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tdelete not set");
          field.Name = "tdelete";
          field.Type = TType.Struct;
          field.ID = 6;
          oprot.WriteFieldBegin(field);
          Tdelete.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("checkAndDelete_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Row: ");
        __sb.Append(Row);
        __sb.Append(", Family: ");
        __sb.Append(Family);
        __sb.Append(", Qualifier: ");
        __sb.Append(Qualifier);
        if (Value != null && __isset.@value) {
          __sb.Append(", Value: ");
          __sb.Append(Value);
        }
        __sb.Append(", Tdelete: ");
        __sb.Append(Tdelete== null ? "<null>" : Tdelete.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class checkAndDelete_result : TBase
    {
      private bool _success;
      private TIOError _io;

      public bool Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public checkAndDelete_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Bool) {
                  Success = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("checkAndDelete_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.Bool;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("checkAndDelete_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class increment_args : TBase
    {

      /// <summary>
      /// the table to increment the value on
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// the TIncrement to increment
      /// </summary>
      public TIncrement Tincrement { get; set; }

      public increment_args() {
      }

      public increment_args(byte[] table, TIncrement tincrement) : this() {
        this.Table = table;
        this.Tincrement = tincrement;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_tincrement = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Tincrement = new TIncrement();
                  Tincrement.Read(iprot);
                  isset_tincrement = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_tincrement)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tincrement not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("increment_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Tincrement == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tincrement not set");
          field.Name = "tincrement";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Tincrement.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("increment_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Tincrement: ");
        __sb.Append(Tincrement== null ? "<null>" : Tincrement.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class increment_result : TBase
    {
      private TResult _success;
      private TIOError _io;

      public TResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public increment_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new TResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("increment_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("increment_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class append_args : TBase
    {

      /// <summary>
      /// the table to append the value on
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// the TAppend to append
      /// </summary>
      public TAppend Tappend { get; set; }

      public append_args() {
      }

      public append_args(byte[] table, TAppend tappend) : this() {
        this.Table = table;
        this.Tappend = tappend;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_tappend = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Tappend = new TAppend();
                  Tappend.Read(iprot);
                  isset_tappend = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_tappend)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tappend not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("append_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Tappend == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tappend not set");
          field.Name = "tappend";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Tappend.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("append_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Tappend: ");
        __sb.Append(Tappend== null ? "<null>" : Tappend.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class append_result : TBase
    {
      private TResult _success;
      private TIOError _io;

      public TResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public append_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new TResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("append_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("append_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class openScanner_args : TBase
    {

      /// <summary>
      /// the table to get the Scanner for
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// the scan object to get a Scanner for
      /// </summary>
      public TScan Tscan { get; set; }

      public openScanner_args() {
      }

      public openScanner_args(byte[] table, TScan tscan) : this() {
        this.Table = table;
        this.Tscan = tscan;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_tscan = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Tscan = new TScan();
                  Tscan.Read(iprot);
                  isset_tscan = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_tscan)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tscan not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("openScanner_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Tscan == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tscan not set");
          field.Name = "tscan";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Tscan.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("openScanner_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Tscan: ");
        __sb.Append(Tscan== null ? "<null>" : Tscan.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class openScanner_result : TBase
    {
      private int _success;
      private TIOError _io;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public openScanner_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("openScanner_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("openScanner_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getScannerRows_args : TBase
    {
      private int _numRows;

      /// <summary>
      /// the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
      /// </summary>
      public int ScannerId { get; set; }

      /// <summary>
      /// number of rows to return
      /// </summary>
      public int NumRows
      {
        get
        {
          return _numRows;
        }
        set
        {
          __isset.numRows = true;
          this._numRows = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool numRows;
      }

      public getScannerRows_args() {
        this._numRows = 1;
        this.__isset.numRows = true;
      }

      public getScannerRows_args(int scannerId) : this() {
        this.ScannerId = scannerId;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_scannerId = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.I32) {
                  ScannerId = iprot.ReadI32();
                  isset_scannerId = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.I32) {
                  NumRows = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_scannerId)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field ScannerId not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getScannerRows_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "scannerId";
          field.Type = TType.I32;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32(ScannerId);
          oprot.WriteFieldEnd();
          if (__isset.numRows) {
            field.Name = "numRows";
            field.Type = TType.I32;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(NumRows);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getScannerRows_args(");
        __sb.Append(", ScannerId: ");
        __sb.Append(ScannerId);
        if (__isset.numRows) {
          __sb.Append(", NumRows: ");
          __sb.Append(NumRows);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getScannerRows_result : TBase
    {
      private List<TResult> _success;
      private TIOError _io;
      private TIllegalArgument _ia;

      public List<TResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }

      /// <summary>
      /// if the scannerId is invalid
      /// </summary>
      public TIllegalArgument Ia
      {
        get
        {
          return _ia;
        }
        set
        {
          __isset.ia = true;
          this._ia = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
        public bool ia;
      }

      public getScannerRows_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TResult>();
                    TList _list99 = iprot.ReadListBegin();
                    for( int _i100 = 0; _i100 < _list99.Count; ++_i100)
                    {
                      TResult _elem101;
                      _elem101 = new TResult();
                      _elem101.Read(iprot);
                      Success.Add(_elem101);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ia = new TIllegalArgument();
                  Ia.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getScannerRows_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TResult _iter102 in Success)
                {
                  _iter102.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ia) {
            if (Ia != null) {
              field.Name = "Ia";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ia.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getScannerRows_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        if (Ia != null && __isset.ia) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ia: ");
          __sb.Append(Ia== null ? "<null>" : Ia.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class closeScanner_args : TBase
    {

      /// <summary>
      /// the Id of the Scanner to close *
      /// </summary>
      public int ScannerId { get; set; }

      public closeScanner_args() {
      }

      public closeScanner_args(int scannerId) : this() {
        this.ScannerId = scannerId;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_scannerId = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.I32) {
                  ScannerId = iprot.ReadI32();
                  isset_scannerId = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_scannerId)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field ScannerId not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("closeScanner_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          field.Name = "scannerId";
          field.Type = TType.I32;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32(ScannerId);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("closeScanner_args(");
        __sb.Append(", ScannerId: ");
        __sb.Append(ScannerId);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class closeScanner_result : TBase
    {
      private TIOError _io;
      private TIllegalArgument _ia;

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }

      /// <summary>
      /// if the scannerId is invalid
      /// </summary>
      public TIllegalArgument Ia
      {
        get
        {
          return _ia;
        }
        set
        {
          __isset.ia = true;
          this._ia = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
        public bool ia;
      }

      public closeScanner_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Ia = new TIllegalArgument();
                  Ia.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("closeScanner_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.ia) {
            if (Ia != null) {
              field.Name = "Ia";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              Ia.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("closeScanner_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        if (Ia != null && __isset.ia) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Ia: ");
          __sb.Append(Ia== null ? "<null>" : Ia.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class mutateRow_args : TBase
    {

      /// <summary>
      /// table to apply the mutations
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// mutations to apply
      /// </summary>
      public TRowMutations TrowMutations { get; set; }

      public mutateRow_args() {
      }

      public mutateRow_args(byte[] table, TRowMutations trowMutations) : this() {
        this.Table = table;
        this.TrowMutations = trowMutations;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_trowMutations = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  TrowMutations = new TRowMutations();
                  TrowMutations.Read(iprot);
                  isset_trowMutations = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_trowMutations)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field TrowMutations not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("mutateRow_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (TrowMutations == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field TrowMutations not set");
          field.Name = "trowMutations";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          TrowMutations.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("mutateRow_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", TrowMutations: ");
        __sb.Append(TrowMutations== null ? "<null>" : TrowMutations.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class mutateRow_result : TBase
    {
      private TIOError _io;

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool io;
      }

      public mutateRow_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("mutateRow_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("mutateRow_result(");
        bool __first = true;
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getScannerResults_args : TBase
    {
      private int _numRows;

      /// <summary>
      /// the table to get the Scanner for
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// the scan object to get a Scanner for
      /// </summary>
      public TScan Tscan { get; set; }

      /// <summary>
      /// number of rows to return
      /// </summary>
      public int NumRows
      {
        get
        {
          return _numRows;
        }
        set
        {
          __isset.numRows = true;
          this._numRows = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool numRows;
      }

      public getScannerResults_args() {
        this._numRows = 1;
        this.__isset.numRows = true;
      }

      public getScannerResults_args(byte[] table, TScan tscan) : this() {
        this.Table = table;
        this.Tscan = tscan;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_tscan = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Tscan = new TScan();
                  Tscan.Read(iprot);
                  isset_tscan = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I32) {
                  NumRows = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_tscan)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tscan not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getScannerResults_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Tscan == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Tscan not set");
          field.Name = "tscan";
          field.Type = TType.Struct;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          Tscan.Write(oprot);
          oprot.WriteFieldEnd();
          if (__isset.numRows) {
            field.Name = "numRows";
            field.Type = TType.I32;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(NumRows);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getScannerResults_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Tscan: ");
        __sb.Append(Tscan== null ? "<null>" : Tscan.ToString());
        if (__isset.numRows) {
          __sb.Append(", NumRows: ");
          __sb.Append(NumRows);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getScannerResults_result : TBase
    {
      private List<TResult> _success;
      private TIOError _io;

      public List<TResult> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getScannerResults_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<TResult>();
                    TList _list103 = iprot.ReadListBegin();
                    for( int _i104 = 0; _i104 < _list103.Count; ++_i104)
                    {
                      TResult _elem105;
                      _elem105 = new TResult();
                      _elem105.Read(iprot);
                      Success.Add(_elem105);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getScannerResults_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (TResult _iter106 in Success)
                {
                  _iter106.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getScannerResults_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRegionLocation_args : TBase
    {
      private bool _reload;

      public byte[] Table { get; set; }

      public byte[] Row { get; set; }

      public bool Reload
      {
        get
        {
          return _reload;
        }
        set
        {
          __isset.reload = true;
          this._reload = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool reload;
      }

      public getRegionLocation_args() {
      }

      public getRegionLocation_args(byte[] table, byte[] row) : this() {
        this.Table = table;
        this.Row = row;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_row = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                  isset_row = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Bool) {
                  Reload = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_row)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Row not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRegionLocation_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Row == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Row not set");
          field.Name = "row";
          field.Type = TType.String;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Row);
          oprot.WriteFieldEnd();
          if (__isset.reload) {
            field.Name = "reload";
            field.Type = TType.Bool;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(Reload);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRegionLocation_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Row: ");
        __sb.Append(Row);
        if (__isset.reload) {
          __sb.Append(", Reload: ");
          __sb.Append(Reload);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getRegionLocation_result : TBase
    {
      private THRegionLocation _success;
      private TIOError _io;

      public THRegionLocation Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getRegionLocation_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new THRegionLocation();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getRegionLocation_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getRegionLocation_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getAllRegionLocations_args : TBase
    {

      public byte[] Table { get; set; }

      public getAllRegionLocations_args() {
      }

      public getAllRegionLocations_args(byte[] table) : this() {
        this.Table = table;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getAllRegionLocations_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getAllRegionLocations_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getAllRegionLocations_result : TBase
    {
      private List<THRegionLocation> _success;
      private TIOError _io;

      public List<THRegionLocation> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public getAllRegionLocations_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<THRegionLocation>();
                    TList _list107 = iprot.ReadListBegin();
                    for( int _i108 = 0; _i108 < _list107.Count; ++_i108)
                    {
                      THRegionLocation _elem109;
                      _elem109 = new THRegionLocation();
                      _elem109.Read(iprot);
                      Success.Add(_elem109);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getAllRegionLocations_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (THRegionLocation _iter110 in Success)
                {
                  _iter110.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getAllRegionLocations_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class checkAndMutate_args : TBase
    {
      private byte[] _value;

      /// <summary>
      /// to check in and delete from
      /// </summary>
      public byte[] Table { get; set; }

      /// <summary>
      /// row to check
      /// </summary>
      public byte[] Row { get; set; }

      /// <summary>
      /// column family to check
      /// </summary>
      public byte[] Family { get; set; }

      /// <summary>
      /// column qualifier to check
      /// </summary>
      public byte[] Qualifier { get; set; }

      /// <summary>
      /// comparison to make on the value
      /// 
      /// <seealso cref="TCompareOp"/>
      /// </summary>
      public TCompareOp CompareOp { get; set; }

      /// <summary>
      /// the expected value to be compared against, if not provided the
      /// check is for the non-existence of the column in question
      /// </summary>
      public byte[] Value
      {
        get
        {
          return _value;
        }
        set
        {
          __isset.@value = true;
          this._value = value;
        }
      }

      /// <summary>
      /// row mutations to execute if the value matches
      /// </summary>
      public TRowMutations RowMutations { get; set; }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool @value;
      }

      public checkAndMutate_args() {
      }

      public checkAndMutate_args(byte[] table, byte[] row, byte[] family, byte[] qualifier, TCompareOp compareOp, TRowMutations rowMutations) : this() {
        this.Table = table;
        this.Row = row;
        this.Family = family;
        this.Qualifier = qualifier;
        this.CompareOp = compareOp;
        this.RowMutations = rowMutations;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          bool isset_table = false;
          bool isset_row = false;
          bool isset_family = false;
          bool isset_qualifier = false;
          bool isset_compareOp = false;
          bool isset_rowMutations = false;
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Table = iprot.ReadBinary();
                  isset_table = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Row = iprot.ReadBinary();
                  isset_row = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Family = iprot.ReadBinary();
                  isset_family = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.String) {
                  Qualifier = iprot.ReadBinary();
                  isset_qualifier = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.I32) {
                  CompareOp = (TCompareOp)iprot.ReadI32();
                  isset_compareOp = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 6:
                if (field.Type == TType.String) {
                  Value = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 7:
                if (field.Type == TType.Struct) {
                  RowMutations = new TRowMutations();
                  RowMutations.Read(iprot);
                  isset_rowMutations = true;
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
          if (!isset_table)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          if (!isset_row)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Row not set");
          if (!isset_family)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Family not set");
          if (!isset_qualifier)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Qualifier not set");
          if (!isset_compareOp)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field CompareOp not set");
          if (!isset_rowMutations)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field RowMutations not set");
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("checkAndMutate_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Table == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Table not set");
          field.Name = "table";
          field.Type = TType.String;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Table);
          oprot.WriteFieldEnd();
          if (Row == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Row not set");
          field.Name = "row";
          field.Type = TType.String;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Row);
          oprot.WriteFieldEnd();
          if (Family == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Family not set");
          field.Name = "family";
          field.Type = TType.String;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Family);
          oprot.WriteFieldEnd();
          if (Qualifier == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Qualifier not set");
          field.Name = "qualifier";
          field.Type = TType.String;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(Qualifier);
          oprot.WriteFieldEnd();
          field.Name = "compareOp";
          field.Type = TType.I32;
          field.ID = 5;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32((int)CompareOp);
          oprot.WriteFieldEnd();
          if (Value != null && __isset.@value) {
            field.Name = "value";
            field.Type = TType.String;
            field.ID = 6;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(Value);
            oprot.WriteFieldEnd();
          }
          if (RowMutations == null)
            throw new TProtocolException(TProtocolException.INVALID_DATA, "required field RowMutations not set");
          field.Name = "rowMutations";
          field.Type = TType.Struct;
          field.ID = 7;
          oprot.WriteFieldBegin(field);
          RowMutations.Write(oprot);
          oprot.WriteFieldEnd();
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("checkAndMutate_args(");
        __sb.Append(", Table: ");
        __sb.Append(Table);
        __sb.Append(", Row: ");
        __sb.Append(Row);
        __sb.Append(", Family: ");
        __sb.Append(Family);
        __sb.Append(", Qualifier: ");
        __sb.Append(Qualifier);
        __sb.Append(", CompareOp: ");
        __sb.Append(CompareOp);
        if (Value != null && __isset.@value) {
          __sb.Append(", Value: ");
          __sb.Append(Value);
        }
        __sb.Append(", RowMutations: ");
        __sb.Append(RowMutations== null ? "<null>" : RowMutations.ToString());
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class checkAndMutate_result : TBase
    {
      private bool _success;
      private TIOError _io;

      public bool Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public TIOError Io
      {
        get
        {
          return _io;
        }
        set
        {
          __isset.io = true;
          this._io = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool io;
      }

      public checkAndMutate_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Bool) {
                  Success = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  Io = new TIOError();
                  Io.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("checkAndMutate_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.Bool;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.io) {
            if (Io != null) {
              field.Name = "Io";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              Io.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("checkAndMutate_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (Io != null && __isset.io) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Io: ");
          __sb.Append(Io== null ? "<null>" : Io.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }

  }
}
